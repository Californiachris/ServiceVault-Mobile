# === Fix-Track one-shot installer (Replit/Node 18+) ===
set -e

# 1) Project skeleton
mkdir -p src/app/api src/app/tools src/app src/lib prisma scripts public
mkdir -p src/app/api/auth/signin src/app/api/auth/signout
mkdir -p src/app/api/identifiers/batch src/app/api/identifiers/claim
mkdir -p src/app/api/properties/master src/app/api/uploads
mkdir -p src/app/api/reports/home-health src/app/api/inspections/append
mkdir -p src/app/api/cron/reminders src/app/api/stripe/checkout
mkdir -p src/app/api/stripe/portal src/app/api/webhooks/stripe
mkdir -p src/app/scan src/app/tools/identifiers src/app/tools/assets
mkdir -p src/app/tools/documents src/app/tools/reports src/app/tools/inspections
mkdir -p src/app/tools/reminders
mkdir -p public/qrcodes public/uploads public/reports

# 2) package.json
cat > package.json <<'EOF'
{
  "name": "fixtrack-pro",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3000",
    "build": "next build",
    "start": "next start -p 3000",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev --name init",
    "seed": "tsx scripts/seed.ts",
    "webhook": "stripe listen --forward-to localhost:3000/api/webhooks/stripe"
  },
  "dependencies": {
    "@prisma/client": "5.19.1",
    "@stripe/stripe-js": "3.4.1",
    "bcryptjs": "2.4.3",
    "date-fns": "3.6.0",
    "jsonwebtoken": "9.0.2",
    "next": "14.2.5",
    "pdfkit": "0.15.0",
    "qrcode": "1.5.3",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "stripe": "14.25.0",
    "zod": "3.23.8"
  },
  "devDependencies": {
    "prisma": "5.19.1",
    "typescript": "5.6.2",
    "tsx": "4.17.0",
    "@types/jsonwebtoken": "9.0.6",
    "@types/node": "20.14.10",
    "@types/react": "18.3.3",
    "@types/react-dom": "18.3.0",
    "@types/pdfkit": "0.13.5"
  }
}
EOF

# 3) tsconfig
cat > tsconfig.json <<'EOF'
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": false,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "baseUrl": ".",
    "paths": { "@/*": ["src/*"] }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
EOF

# 4) next config
cat > next.config.mjs <<'EOF'
/** @type {import('next').NextConfig} */
const nextConfig = { experimental: { serverActions: true } };
export default nextConfig;
EOF

# 5) .env.example with dummy Stripe (auto-stubs)
cat > .env.example <<'EOF'
DATABASE_URL="file:./dev.db"
NEXTAUTH_URL="http://localhost:3000"
NEXTAUTH_SECRET="replace-with-strong-secret"

# Stripe keys (FAKE triggers safe stubs)
STRIPE_SECRET_KEY="sk_test_FAKE"
STRIPE_WEBHOOK_SECRET="whsec_FAKE"

# Contractor plans
STRIPE_PRICE_CONTRACTOR_50="price_FAKE_19_month"
STRIPE_PRICE_CONTRACTOR_100="price_FAKE_29_month"

# Homeowner: lifetime + annual maintenance
STRIPE_PRICE_HOME_LIFETIME="price_FAKE_100_onetime"
STRIPE_PRICE_HOME_ANNUAL="price_FAKE_15_year"
EOF

# 6) Prisma schema (SQLite dev)
cat > prisma/schema.prisma <<'EOF'
generator client { provider = "prisma-client-js" }
datasource db { provider = "sqlite"; url = env("DATABASE_URL") }

model User {
  id              String   @id @default(cuid())
  email           String   @unique
  name            String?
  passwordHash    String
  role            Role     @default(HOMEOWNER)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  contractor      Contractor?
  properties      Property[]
  inspections     Inspection[]
  subscriptions   Subscription[]
  stripeCustomerId String?
}

enum Role { HOMEOWNER CONTRACTOR INSPECTOR ADMIN }

model Contractor {
  id          String  @id @default(cuid())
  userId      String  @unique
  user        User    @relation(fields: [userId], references: [id])
  companyName String
  logoUrl     String?
  plan        String?
  identifiers Identifier[]
  installs    Asset[] @relation("InstallerAssets")
}

model Property {
  id                 String   @id @default(cuid())
  ownerId            String
  owner              User     @relation(fields: [ownerId], references: [id])
  name               String?
  addressLine1       String?
  city               String?
  state              String?
  postalCode         String?
  country            String?
  masterIdentifier   Identifier? @relation("MasterIdentifier", fields: [masterIdentifierId], references: [id])
  masterIdentifierId String?
  assets             Asset[]
  documents          Document[]
  reminders          Reminder[]
  inspections        Inspection[]
  transfers          Transfer[]
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  homePlan           String?
  homeStatus         String?
}

model Identifier {
  id            String    @id @default(cuid())
  code          String    @unique
  type          IdentifierType
  contractorId  String?
  contractor    Contractor? @relation(fields: [contractorId], references: [id])
  claimedAt     DateTime?
  qrPath        String?
  brandLabel    String?
  deactivatedAt DateTime?
  asset         Asset?
  property      Property? @relation("MasterIdentifier")
  createdAt     DateTime  @default(now())
}

enum IdentifierType { ASSET MASTER }

model Asset {
  id            String   @id @default(cuid())
  propertyId    String
  property      Property @relation(fields: [propertyId], references: [id])
  name          String
  category      AssetCategory
  brand         String?
  model         String?
  serial        String?
  installedAt   DateTime?
  identifierId  String? @unique
  identifier    Identifier? @relation(fields: [identifierId], references: [id])
  installerId   String?
  installer     Contractor? @relation("InstallerAssets", fields: [installerId], references: [id])
  status        String?
  events        Event[]
  documents     Document[]
  reminders     Reminder[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

enum AssetCategory { PLUMBING ELECTRICAL HVAC APPLIANCE FURNITURE STRUCTURAL VEHICLE HEAVY_EQUIPMENT OTHER }

model Event {
  id        String   @id @default(cuid())
  assetId   String
  asset     Asset    @relation(fields: [assetId], references: [id])
  type      EventType
  data      Json
  createdBy String?
  createdAt DateTime @default(now())
}

enum EventType { INSTALL SERVICE INSPECTION TRANSFER WARRANTY_UPLOAD MANUAL_UPLOAD NOTE }

model Document {
  id         String   @id @default(cuid())
  assetId    String?
  asset      Asset?   @relation(fields: [assetId], references: [id])
  propertyId String?
  property   Property? @relation(fields: [propertyId], references: [id])
  type       DocumentType
  title      String
  path       String
  uploadedAt DateTime @default(now())
}

enum DocumentType { RECEIPT WARRANTY MANUAL INSPECTION QUOTE INVOICE OTHER }

model Reminder {
  id         String   @id @default(cuid())
  assetId    String?
  asset      Asset?   @relation(fields: [assetId], references: [id])
  propertyId String?
  property   Property? @relation(fields: [propertyId], references: [id])
  dueAt      DateTime
  type       String
  status     String   @default("PENDING")
  createdAt  DateTime @default(now())
  completedAt DateTime?
}

model Transfer {
  id          String   @id @default(cuid())
  propertyId  String
  property    Property @relation(fields: [propertyId], references: [id])
  fromUserId  String
  toUserId    String
  status      String   @default("ESCROW")
  initiatedAt DateTime @default(now())
  completedAt DateTime?
  signature   String?
}

model Inspection {
  id           String   @id @default(cuid())
  propertyId   String
  property     Property @relation(fields: [propertyId], references: [id])
  inspectorId  String
  inspector    User     @relation(fields: [inspectorId], references: [id])
  jurisdiction String?
  checklist    Json?
  result       String?
  signedAt     DateTime?
  createdAt    DateTime @default(now())
}

model Subscription {
  id               String   @id @default(cuid())
  userId           String
  user             User     @relation(fields: [userId], references: [id])
  stripeCustomerId String?
  stripeSubId      String?
  priceId          String?
  plan             String?
  status           String?
  currentPeriodEnd DateTime?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}
EOF

# 7) Global styles
mkdir -p src/app
cat > src/app/globals.css <<'EOF'
:root { --bg:#0b1220; --card:#101a2e; --text:#eaf2ff; --muted:#b9c6e0; --brand:#66e2d5; }
*{box-sizing:border-box}
html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto}
a{color:var(--brand);text-decoration:none}
.container{max-width:1100px;margin:0 auto;padding:24px}
.card{background:var(--card);border:1px solid #223150;border-radius:16px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,.25);margin-bottom:16px}
.input{width:100%;padding:10px;border-radius:8px;border:1px solid #2b3c5e;background:#0f1729;color:#eaf2ff}
.button{background:var(--brand);color:#062e2a;padding:10px 16px;border:0;border-radius:10px;font-weight:700;cursor:pointer}
.grid{display:grid;gap:16px;grid-template-columns:repeat(auto-fit,minmax(260px,1fr))}
.badge{display:inline-block;padding:4px 10px;border-radius:999px;background:#11233d;color:#a4c7ff;border:1px solid #2b3c5e}
h1,h2,h3{margin:8px 0}
small{color:var(--muted)}
hr{border:none;border-top:1px solid #223150;opacity:.4;margin:16px 0}
EOF

# 8) Layout + Landing + Dashboard
cat > src/app/layout.tsx <<'EOF'
import "./globals.css";
import Link from "next/link";
export const metadata = { title: "Fix-Track", description: "One scan, the whole history." };
export default function RootLayout({ children }: { children: React.ReactNode }){
  return (
    <html lang="en"><body>
      <div className="container">
        <header style={{display:'flex',justifyContent:'space-between',alignItems:'center',marginBottom:16}}>
          <Link href="/"><h2>Fix-Track</h2></Link>
          <nav style={{display:'flex',gap:12}}>
            <Link href="/pricing">Pricing</Link>
            <Link href="/dashboard">Dashboard</Link>
            <Link href="/scan">Scan</Link>
            <Link href="/signin">Sign in</Link>
          </nav>
        </header>
        {children}
      </div>
    </body></html>
  );
}
EOF

cat > src/app/page.tsx <<'EOF'
export default function Home(){
  return (<div className="card"><h1>Fix-Track</h1><p>Carfax-style history for installs, services, warranties, inspections, recalls, transfers — across homes, fleets, farms, and more.</p></div>);
}
EOF

cat > src/app/dashboard/page.tsx <<'EOF'
import Link from "next/link";
export default function Dashboard(){
  return (
    <div className="grid">
      <div className="card"><h3>Identifiers</h3><p>Batch generate QR/NFC codes with branding.</p><Link className="button" href="/tools/identifiers">Open</Link></div>
      <div className="card"><h3>Properties & Assets</h3><p>Create master code and bind assets.</p><Link className="button" href="/tools/assets">Open</Link></div>
      <div className="card"><h3>Documents</h3><p>Upload receipts/warranties/manuals.</p><Link className="button" href="/tools/documents">Open</Link></div>
      <div className="card"><h3>Reports</h3><p>Generate a Home Health Certificate™.</p><Link className="button" href="/tools/reports">Open</Link></div>
      <div className="card"><h3>Inspections</h3><p>Append checklist results.</p><Link className="button" href="/tools/inspections">Open</Link></div>
      <div className="card"><h3>Reminders</h3><p>Run reminder cron.</p><Link className="button" href="/tools/reminders">Open</Link></div>
      <div className="card"><h3>Subscriptions</h3><p>Manage contractor & homeowner plans.</p><Link className="button" href="/pricing">Open</Link></div>
    </div>
  );
}
EOF

# 9) DB & session utils
mkdir -p src/lib
cat > src/lib/db.ts <<'EOF'
import { PrismaClient } from "@prisma/client";
const g = global as unknown as { prisma?: PrismaClient };
export const prisma = g.prisma || new PrismaClient();
if (process.env.NODE_ENV !== "production") g.prisma = prisma;
EOF

cat > src/lib/session.ts <<'EOF'
import { cookies } from 'next/headers';
export function setSession(val: string){ cookies().set('fixtrack_session', val, { httpOnly: false, sameSite:'lax', path:'/' }); }
export function clearSession(){ cookies().delete('fixtrack_session'); }
export function getSession(){ return cookies().get('fixtrack_session')?.value || null; }
EOF

cat > src/lib/utils.ts <<'EOF'
export function code(n=10){
  const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
  let s = ""; for(let i=0;i<n;i++) s += chars[Math.floor(Math.random()*chars.length)];
  return s;
}
EOF

# 10) Sign in page + API
mkdir -p src/app/api/auth/signin src/app/api/auth/signout
cat > src/app/signin/page.tsx <<'EOF'
'use client';
import { useState } from 'react';
export default function SignIn(){
  const [email,setEmail]=useState('admin@fixtrack.app');
  const [password,setPassword]=useState('password123');
  const [msg,setMsg]=useState('');
  async function submit(e:any){
    e.preventDefault();
    const r = await fetch('/api/auth/signin',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({email,password})});
    if(r.ok) location.href='/dashboard'; else setMsg((await r.json()).error||'Failed');
  }
  return (<div className="card" style={{maxWidth:420}}>
    <h2>Sign in</h2>
    <form onSubmit={submit} className="grid">
      <input className="input" placeholder="Email" value={email} onChange={e=>setEmail(e.target.value)}/>
      <input className="input" type="password" placeholder="Password" value={password} onChange={e=>setPassword(e.target.value)}/>
      <button className="button" type="submit">Sign in</button>
    </form>
    <p style={{color:'salmon'}}>{msg}</p><small>Demo creds are seeded.</small>
  </div>);
}
EOF

cat > src/app/api/auth/signin/route.ts <<'EOF'
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import bcrypt from "bcryptjs";
import { setSession } from "@/lib/session";
export async function POST(req: NextRequest){
  const { email, password } = await req.json();
  const user = await prisma.user.findUnique({ where: { email } });
  if(!user) return NextResponse.json({error:"User not found"},{status:404});
  const ok = await bcrypt.compare(password, user.passwordHash);
  if(!ok) return NextResponse.json({error:"Invalid credentials"},{status:401});
  setSession(user.id);
  return NextResponse.json({ok:true});
}
EOF

cat > src/app/api/auth/signout/route.ts <<'EOF'
import { NextResponse } from "next/server";
import { clearSession } from "@/lib/session";
export async function POST(){ clearSession(); return NextResponse.json({ok:true}); }
EOF

# 11) Tools UI
cat > src/app/tools/identifiers/page.tsx <<'EOF'
'use client';
import { useState } from 'react';
export default function IdentifiersTool(){
  const [count,setCount]=useState(10);
  const [brand,setBrand]=useState('Your Company');
  const [type,setType]=useState<'ASSET'|'MASTER'>('ASSET');
  const [res,setRes]=useState<any>(null);
  async function generate(){
    const r = await fetch('/api/identifiers/batch',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({count, type, brandLabel:brand})});
    setRes(await r.json());
  }
  return (<div className="card">
    <h2>Batch Generate Identifiers</h2>
    <div className="grid">
      <label>Count <input className="input" type="number" value={count} onChange={e=>setCount(parseInt(e.target.value||'0'))}/></label>
      <label>Type <select className="input" value={type} onChange={e=>setType(e.target.value as any)}><option>ASSET</option><option>MASTER</option></select></label>
      <label>Brand Label <input className="input" value={brand} onChange={e=>setBrand(e.target.value)}/></label>
    </div>
    <button className="button" style={{marginTop:12}} onClick={generate}>Generate</button>
    {res?.created && <div style={{marginTop:16}}>
      <h3>Created {res.created.length} identifiers</h3>
      <div className="grid">{res.created.map((id:any)=>(<div key={id.id} className="card"><div className="badge">{id.type}</div><p><b>{id.code}</b></p>{id.qrPath && <img src={id.qrPath} style={{width:160}}/>}<small>{id.brandLabel}</small></div>))}</div>
    </div>}
  </div>);
}
EOF

cat > src/app/tools/assets/page.tsx <<'EOF'
'use client';
import { useState } from 'react';
export default function AssetsTool(){
  const [code,setCode]=useState('');
  const [name,setName]=useState('Water Heater');
  const [category,setCategory]=useState('PLUMBING');
  const [propertyName,setPropertyName]=useState('Main Residence');
  const [master,setMaster]=useState('');
  async function claim(){
    const r = await fetch('/api/identifiers/claim',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({code, asset:{name, category}, property:{name:propertyName}})});
    alert(JSON.stringify(await r.json(),null,2));
  }
  async function setMasterCode(){
    const r = await fetch('/api/properties/master',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({propertyName, code: master})});
    alert(JSON.stringify(await r.json(),null,2));
  }
  return (<div className="card">
    <h2>Assets & Master Code</h2>
    <div className="grid">
      <label>Identifier Code <input className="input" value={code} onChange={e=>setCode(e.target.value)}/></label>
      <label>Asset Name <input className="input" value={name} onChange={e=>setName(e.target.value)}/></label>
      <label>Category
        <select className="input" value={category} onChange={e=>setCategory(e.target.value)}>
          <option>PLUMBING</option><option>ELECTRICAL</option><option>HVAC</option>
          <option>APPLIANCE</option><option>FURNITURE</option><option>STRUCTURAL</option>
          <option>VEHICLE</option><option>HEAVY_EQUIPMENT</option><option>OTHER</option>
        </select>
      </label>
      <label>Property Name <input className="input" value={propertyName} onChange={e=>setPropertyName(e.target.value)}/></label>
    </div>
    <button className="button" style={{marginTop:12}} onClick={claim}>Claim & Bind Asset</button>
    <hr/>
    <h3>Set Master Code for Property</h3>
    <div className="grid">
      <label>Property Name <input className="input" value={propertyName} onChange={e=>setPropertyName(e.target.value)}/></label>
      <label>Master Identifier Code <input className="input" value={master} onChange={e=>setMaster(e.target.value)}/></label>
    </div>
    <button className="button" style={{marginTop:12}} onClick={setMasterCode}>Assign Master Code</button>
  </div>);
}
EOF

cat > src/app/tools/documents/page.tsx <<'EOF'
'use client';
import { useState } from 'react';
export default function DocumentsTool(){
  const [assetId,setAssetId]=useState('');
  const [title,setTitle]=useState('Warranty');
  const [type,setType]=useState('WARRANTY');
  const [file,setFile]=useState<File|null>(null);
  async function upload(){
    if(!file) return alert('Choose a file');
    const fd = new FormData();
    fd.set('assetId', assetId);
    fd.set('type', type);
    fd.set('title', title);
    fd.set('file', file);
    const r = await fetch('/api/uploads', { method:'POST', body: fd });
    alert(JSON.stringify(await r.json(),null,2));
  }
  return (<div className="card">
    <h2>Upload Document</h2>
    <div className="grid">
      <label>Asset ID <input className="input" value={assetId} onChange={e=>setAssetId(e.target.value)}/></label>
      <label>Title <input className="input" value={title} onChange={e=>setTitle(e.target.value)}/></label>
      <label>Type
        <select className="input" value={type} onChange={e=>setType(e.target.value)}>
          <option>RECEIPT</option><option>WARRANTY</option><option>MANUAL</option>
          <option>INSPECTION</option><option>QUOTE</option><option>INVOICE</option><option>OTHER</option>
        </select>
      </label>
      <label>File <input className="input" type="file" onChange={e=>setFile(e.target.files?.[0]||null)}/></label>
    </div>
    <button className="button" style={{marginTop:12}} onClick={upload}>Upload</button>
  </div>);
}
EOF

cat > src/app/tools/reports/page.tsx <<'EOF'
'use client';
export default function ReportsTool(){
  async function gen(){
    const r = await fetch('/api/reports/home-health',{method:'POST'});
    const data = await r.json();
    if(data.url) window.open(data.url, '_blank'); else alert('Failed');
  }
  return (<div className="card"><h2>Home Health Certificate™</h2><p>Generate a summary report for a property.</p><button className="button" onClick={gen}>Generate Report</button></div>);
}
EOF

cat > src/app/tools/inspections/page.tsx <<'EOF'
'use client';
import { useState } from 'react';
export default function InspectionsTool(){
  const [propertyName,setPropertyName]=useState('Main Residence');
  const [result,setResult]=useState('PASS');
  async function submit(){
    const r = await fetch('/api/inspections/append',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({propertyName,result,checklist:{panel:'OK',gfci:'OK',bonding:'OK'}})});
    alert(JSON.stringify(await r.json(),null,2));
  }
  return (<div className="card"><h2>Append Inspection</h2><div className="grid"><label>Property Name <input className="input" value={propertyName} onChange={e=>setPropertyName(e.target.value)}/></label><label>Result <select className="input" value={result} onChange={e=>setResult(e.target.value)}><option>PASS</option><option>FAIL</option><option>NOTES</option></select></label></div><button className="button" style={{marginTop:12}} onClick={submit}>Append</button></div>);
}
EOF

cat > src/app/tools/reminders/page.tsx <<'EOF'
'use client';
export default function RemindersTool(){
  async function run(){ const r = await fetch('/api/cron/reminders'); alert(JSON.stringify(await r.json(),null,2)); }
  return (<div className="card"><h2>Reminders</h2><p>Run due reminders job.</p><button className="button" onClick={run}>Run Now</button></div>);
}
EOF

# 12) Scan page
cat > src/app/scan/page.tsx <<'EOF'
'use client';
import { useEffect, useState } from 'react';
export default function ScanPage(){
  const [code,setCode]=useState<string|undefined>(undefined);
  useEffect(()=>{ const p = new URLSearchParams(window.location.search); const c = p.get('code')||''; if(c) setCode(c); },[]);
  return (<div className="card"><h2>Scan Result</h2>{code?<p>Identifier code: <b>{code}</b></p>:<p>No code in URL. Use a generated QR.</p>}<p>Next: claim and bind inside <a href="/tools/assets">Assets Tool</a>.</p></div>);
}
EOF

# 13) API routes
cat > src/app/api/identifiers/batch/route.ts <<'EOF'
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import QRCode from "qrcode";
import { code as gen } from "@/lib/utils";
import path from "path";
import fs from "fs";

export async function POST(req: NextRequest){
  const body = await req.json();
  const count = Math.min(Number(body.count||0), 500);
  const type = (body.type || "ASSET") as "ASSET" | "MASTER";
  const brandLabel = body.brandLabel || null;
  if(!count || count<1) return NextResponse.json({error:"count required"}, {status:400});

  const created:any[] = [];
  const dir = path.join(process.cwd(), "public", "qrcodes");
  fs.mkdirSync(dir, { recursive: true });

  const base = process.env.NEXTAUTH_URL || "http://localhost:3000";
  for(let i=0;i<count;i++){
    const code = `${type[0]}-${gen(4)}-${gen(4)}`;
    const rec = await prisma.identifier.create({ data: { code, type, brandLabel } });
    const file = path.join(dir, `${rec.id}.png`);
    await QRCode.toFile(file, `${base}/scan?code=${encodeURIComponent(code)}`, { margin: 1, width: 512 });
    const qrPath = `/qrcodes/${rec.id}.png`;
    await prisma.identifier.update({ where: { id: rec.id }, data: { qrPath } });
    created.push({ ...rec, qrPath });
  }
  return NextResponse.json({ created });
}
EOF

cat > src/app/api/identifiers/claim/route.ts <<'EOF'
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
export async function POST(req: NextRequest){
  const body = await req.json();
  const { code, asset, property } = body || {};
  if(!code) return NextResponse.json({error:"code required"}, {status:400});

  const ident = await prisma.identifier.findUnique({ where: { code } });
  if(!ident) return NextResponse.json({error:"identifier not found"}, {status:404});

  let prop = await prisma.property.findFirst({ where: { name: property?.name || "" } });
  if(!prop){
    const owner = await prisma.user.upsert({
      where: { email: "owner@example.com" },
      update: {},
      create: { email: "owner@example.com", passwordHash: "$2a$10$0D9C8aYp1hJk5V43nHz8Oe5sM4Q3Z0O8pI9b4lCk8y1U5QmNwz0yW", role: "HOMEOWNER", name: "Demo Owner" }
    });
    prop = await prisma.property.create({ data: { ownerId: owner.id, name: property?.name || "Property" } });
  }

  const assetRec = await prisma.asset.create({
    data: {
      propertyId: prop.id,
      name: asset?.name || "Asset",
      category: asset?.category || "OTHER",
      identifierId: ident.id,
      installedAt: new Date()
    }
  });

  await prisma.identifier.update({ where: { id: ident.id }, data: { claimedAt: new Date() } });
  await prisma.event.create({ data: { assetId: assetRec.id, type: "INSTALL", data: { note: "Initial claim/install" } } });

  return NextResponse.json({ property: prop, asset: assetRec });
}
EOF

cat > src/app/api/properties/master/route.ts <<'EOF'
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
export async function POST(req: NextRequest){
  const { propertyName, code } = await req.json();
  const prop = await prisma.property.findFirst({ where: { name: propertyName } });
  if(!prop) return NextResponse.json({error:"property not found"},{status:404});
  const ident = await prisma.identifier.findUnique({ where: { code } });
  if(!ident || ident.type!=='MASTER') return NextResponse.json({error:"master identifier required"},{status:400});
  await prisma.property.update({ where: { id: prop.id }, data: { masterIdentifierId: ident.id } });
  return NextResponse.json({ ok:true, propertyId: prop.id, masterIdentifierId: ident.id });
}
EOF

cat > src/app/api/uploads/route.ts <<'EOF'
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import path from "path";
import fs from "fs";
export async function POST(req: NextRequest){
  const form = await req.formData();
  const file = form.get("file") as File | null;
  if(!file) return NextResponse.json({error:"file required"},{status:400});
  const assetId = (form.get("assetId") as string) || null;
  const title = (form.get("title") as string) || file.name || "Document";
  const type = (form.get("type") as string) || "OTHER";
  const bytes = await file.arrayBuffer();
  const buffer = Buffer.from(bytes);
  const dir = path.join(process.cwd(),"public","uploads");
  fs.mkdirSync(dir, { recursive: true });
  const name = `${Date.now()}_${file.name.replace(/[^a-zA-Z0-9._-]/g,"_")}`;
  fs.writeFileSync(path.join(dir, name), buffer);
  const doc = await prisma.document.create({ data: { assetId: assetId || undefined, type, title, path: `/uploads/${name}` } });
  return NextResponse.json({ ok:true, document: doc });
}
EOF

cat > src/app/api/reports/home-health/route.ts <<'EOF'
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import PDFDocument from "pdfkit";
import fs from "fs";
import path from "path";
export async function POST(){
  const prop = await prisma.property.findFirst({ include: { assets: { include:{ events:true, documents:true } }, owner:true, masterIdentifier:true } });
  if(!prop) return NextResponse.json({error:"no property found"},{status:404});
  const dir = path.join(process.cwd(), "public", "reports");
  fs.mkdirSync(dir, { recursive: true });
  const file = path.join(dir, `home_health_${prop.id}.pdf`);
  const doc = new PDFDocument({ size:'LETTER', margin:50 });
  doc.pipe(fs.createWriteStream(file));
  doc.fontSize(18).text("Fix-Track – Home Health Certificate™", { align: 'center' });
  doc.moveDown().fontSize(12).text(`Property: ${prop.name || ''}`);
  doc.text(`Owner: ${prop.owner?.name || prop.owner?.email}`);
  doc.text(`Master Code: ${prop.masterIdentifier?.code || '—'}`);
  doc.moveDown().text("Assets:");
  for(const a of prop.assets){
    doc.moveDown(0.5).fontSize(12).text(`• ${a.name} [${a.category}]  installed: ${a.installedAt || 'n/a'}`);
    if(a.events?.length){ doc.fontSize(10).text(`   Events: ${a.events.map(e=>e.type).join(', ')}`); }
    if(a.documents?.length){ doc.fontSize(10).text(`   Docs: ${a.documents.map(d=>d.type+':'+d.title).join(', ')}`); }
  }
  doc.end();
  return NextResponse.json({ url: `/reports/${path.basename(file)}` });
}
EOF

cat > src/app/api/inspections/append/route.ts <<'EOF'
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
export async function POST(req: NextRequest){
  const { propertyName, result, checklist } = await req.json();
  const prop = await prisma.property.findFirst({ where:{ name: propertyName } });
  if(!prop) return NextResponse.json({error:"property not found"},{status:404});
  const inspector = await prisma.user.upsert({
    where:{ email:"inspector@example.com" },
    update:{},
    create:{ email:"inspector@example.com", passwordHash:"demo", role:"INSPECTOR", name:"Demo Inspector" }
  });
  const ins = await prisma.inspection.create({ data: { propertyId: prop.id, inspectorId: inspector.id, result, checklist } });
  return NextResponse.json({ ok:true, inspectionId: ins.id });
}
EOF

cat > src/app/api/cron/reminders/route.ts <<'EOF'
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";
export async function GET(){
  const now = new Date();
  const due = await prisma.reminder.findMany({ where: { status: 'PENDING', dueAt: { lte: now } } });
  for(const r of due){ await prisma.reminder.update({ where:{ id:r.id }, data:{ status:'SENT' } }); }
  return NextResponse.json({ processed: due.length });
}
EOF

# 14) Pricing page + Stripe (with FAKE stubs)
cat > src/app/pricing/page.tsx <<'EOF'
'use client';
import { useState } from 'react';
type Plan = 'contractor_50' | 'contractor_100' | 'home_lifetime' | 'home_annual';
export default function Pricing(){
  const [plan,setPlan] = useState<Plan>('contractor_50');
  async function checkout(){
    const r = await fetch('/api/stripe/checkout', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ plan }) });
    const data = await r.json();
    if(data.url) window.location.href = data.url; else alert(data.error || 'Checkout failed');
  }
  async function portal(){
    const r = await fetch('/api/stripe/portal', { method:'POST' });
    const data = await r.json();
    if(data.url) window.location.href = data.url; else alert(data.error || 'Portal failed');
  }
  return (
    <div className="card">
      <h2>Choose a plan</h2>
      <div className="grid">
        <div className="card">
          <h3>Contractor — 50 QR/mo</h3><p>$19/month</p>
          <ul><li>50 branded stickers</li><li>Home & light commercial</li><li>Warranty uploads & reminders</li></ul>
          <label><input type="radio" name="plan" value="contractor_50" checked={plan==='contractor_50'} onChange={()=>setPlan('contractor_50')}/> Select</label>
        </div>
        <div className="card">
          <h3>Contractor — 100 QR/mo</h3><p>$29/month</p>
          <ul><li>100 branded stickers</li><li>Fleets & heavy equipment</li><li>Inspector workflows</li></ul>
          <label><input type="radio" name="plan" value="contractor_100" checked={plan==='contractor_100'} onChange={()=>setPlan('contractor_100')}/> Select</label>
        </div>
        <div className="card">
          <h3>Homeowner — Lifetime House Code</h3><p>$100 one-time</p>
          <ul><li>Master “House History” code</li><li>Transferable on sale</li><li>Includes first year hosting</li></ul>
          <label><input type="radio" name="plan" value="home_lifetime" checked={plan==='home_lifetime'} onChange={()=>setPlan('home_lifetime')}/> Select</label>
        </div>
        <div className="card">
          <h3>Homeowner — Annual Hosting</h3><p>$15/year</p>
          <ul><li>Cloud storage & reminders</li><li>Keep history active</li><li>Cancel anytime</li></ul>
          <label><input type="radio" name="plan" value="home_annual" checked={plan==='home_annual'} onChange={()=>setPlan('home_annual')}/> Select</label>
        </div>
      </div>
      <div style={{display:'flex', gap:12, marginTop:16}}>
        <button className="button" onClick={checkout}>Continue to Checkout</button>
        <button className="button" onClick={portal}>Manage Subscription</button>
      </div>
      <small>Dummy Stripe stubs are active. Add real keys later in .env.</small>
    </div>
  );
}
EOF

cat > src/app/api/stripe/checkout/route.ts <<'EOF'
import { NextRequest, NextResponse } from "next/server";
import Stripe from "stripe";
import { prisma } from "@/lib/db";

const hasFake = (v?: string) => !v || v.includes("FAKE");
const stripeKey = process.env.STRIPE_SECRET_KEY || "";
const stripe = hasFake(stripeKey) ? null : new Stripe(stripeKey, { apiVersion: "2024-06-20" } as any);

const PRICE_MAP: Record<string,string|undefined> = {
  contractor_50: process.env.STRIPE_PRICE_CONTRACTOR_50,
  contractor_100: process.env.STRIPE_PRICE_CONTRACTOR_100,
  home_lifetime: process.env.STRIPE_PRICE_HOME_LIFETIME,
  home_annual: process.env.STRIPE_PRICE_HOME_ANNUAL
};

export async function POST(req: NextRequest){
  const { plan } = await req.json();
  const priceId = PRICE_MAP[plan];
  // STUB: return success if using FAKE keys
  if(!stripe){ return NextResponse.json({ url: "/pricing?success=1&stub=1" }); }

  try{
    const user = await prisma.user.findUnique({ where: { email: "admin@fixtrack.app" } });
    if(!user) return NextResponse.json({error:"Seed user missing"}, {status:500});
    let customerId = user.stripeCustomerId;
    if(!customerId){
      const cust = await stripe.customers.create({ email: user.email, name: user.name || undefined });
      customerId = cust.id;
      await prisma.user.update({ where:{ id:user.id }, data:{ stripeCustomerId: customerId }});
    }
    const params: Stripe.Checkout.SessionCreateParams = {
      success_url: `${process.env.NEXTAUTH_URL || "http://localhost:3000"}/pricing?success=1`,
      cancel_url: `${process.env.NEXTAUTH_URL || "http://localhost:3000"}/pricing?canceled=1`,
      customer: customerId,
      line_items: [{ price: priceId, quantity: 1 }],
      mode: (plan === 'home_lifetime') ? 'payment' : 'subscription'
    };
    const session = await stripe.checkout.sessions.create(params);
    return NextResponse.json({ url: session.url });
  }catch(err:any){
    return NextResponse.json({ error: err.message || "Stripe error" }, {status:500});
  }
}
EOF

cat > src/app/api/stripe/portal/route.ts <<'EOF'
import { NextResponse } from "next/server";
import Stripe from "stripe";
import { prisma } from "@/lib/db";
const hasFake = (v?: string) => !v || v.includes("FAKE");
const key = process.env.STRIPE_SECRET_KEY || "";
const stripe = hasFake(key) ? null : new Stripe(key, { apiVersion: "2024-06-20" } as any);
export async function POST(){
  if(!stripe){ return NextResponse.json({ url: "/pricing?portal_stub=1" }); }
  try{
    const user = await prisma.user.findUnique({ where: { email: "admin@fixtrack.app" } });
    if(!user || !user.stripeCustomerId){
      return NextResponse.json({ url: "https://billing.stripe.com/p/login/test_xxx" });
    }
    const portal = await stripe.billingPortal.sessions.create({
      customer: user.stripeCustomerId,
      return_url: `${process.env.NEXTAUTH_URL || "http://localhost:3000"}/pricing`
    });
    return NextResponse.json({ url: portal.url });
  }catch(err:any){
    return NextResponse.json({ error: err.message || "Stripe error" }, {status:500});
  }
}
EOF

cat > src/app/api/webhooks/stripe/route.ts <<'EOF'
import { NextRequest, NextResponse } from "next/server";
export async function POST(){ return NextResponse.json({ received: true, stub: true }); }
EOF

# 15) Scan page already done

# 16) README for agent
cat > README.md <<'EOF'
# Fix-Track — One scan, the whole history.
**Mission:** Carfax-style histories for anything installed, serviced, or owned. Contractors place small branded QR/NFC stickers on assets and an optional master "House History" code. Anyone can scan to see a trusted history; owners and pros can append events, docs, and inspections.

## What’s in this build
- Auth (seeded demo), protected routes
- Identifiers (ASSET/MASTER) with QR images
- Claim & bind flow (INSTALL event)
- Document uploads (warranty/receipt/manual)
- Home Health Certificate™ PDF report
- Inspections append
- Reminders cron (stub)
- Stripe pricing with **safe FAKE stubs**; add real keys later

## Run locally / Replit
1) `cp .env.example .env` (leave FAKE values to use stubs)
2) `npm install`
3) `npx prisma generate && npx prisma migrate dev --name init`
4) `npm run seed`
5) `npm run dev`
6) Sign in: `admin@fixtrack.app` / `password123`

## Flows
- **Identifiers:** /tools/identifiers → generate QR PNGs
- **Claim:** /tools/assets → bind code to property+asset; set master code
- **Docs:** /tools/documents → upload & bind
- **Report:** /tools/reports → generate PDF
- **Pricing:** /pricing → contractor plans & homeowner plans (stubs without real Stripe)

## Production TODOs
- Move uploads to S3/Supabase, swap SQLite→Postgres, add NextAuth, rate limits, RBAC UI, SMS reminders, recall ingest, AI assistant.
EOF

# 17) Seed script
cat > scripts/seed.ts <<'EOF'
import { PrismaClient } from "@prisma/client";
import bcrypt from "bcryptjs";
const prisma = new PrismaClient();
async function main(){
  const admin = await prisma.user.upsert({
    where:{ email:"admin@fixtrack.app" },
    update:{},
    create:{ email:"admin@fixtrack.app", name:"Admin", role:"CONTRACTOR", passwordHash: await bcrypt.hash("password123", 10) }
  });
  await prisma.contractor.upsert({
    where:{ userId: admin.id },
    update:{ companyName: "Demo Contractor" },
    create:{ userId: admin.id, companyName: "Demo Contractor" }
  });
  const owner = await prisma.user.upsert({
    where:{ email:"owner@example.com" },
    update:{},
    create:{ email:"owner@example.com", name:"Demo Owner", role:"HOMEOWNER", passwordHash: await bcrypt.hash("password123", 10) }
  });
  await prisma.property.upsert({
    where:{ id: "seed-prop-1" },
    update:{},
    create:{ id:"seed-prop-1", ownerId: owner.id, name: "Main Residence", addressLine1:"123 Main St", city:"Anytown", state:"CA", postalCode:"90000", country:"USA" }
  });
  console.log("Seeded users, contractor, property");
}
main().finally(()=>prisma.$disconnect());
EOF

# 18) Install deps & initialize
npm install
cp .env.example .env
npx prisma generate
npx prisma migrate dev --name init
npm run seed

echo "✅ Fix-Track installed. Run: npm run dev  (then open the webview)"